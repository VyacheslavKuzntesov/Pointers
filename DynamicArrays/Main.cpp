#include<iostream>

#include"FillRand.h"
#include"Print.h"
#include"Memory.h"
//#include"FillRand.cpp"
//#include"Print.cpp"
//#include"Memory.cpp"

using namespace std;
using std::cout;
using std::cin;

//#define THEORY
//#define DZ
#define delimiter "\n------------------------------------------------\n"
//#define DYNAMIC_MEMORY_1
#define DYNAMIC_MEMORY_2
//#define MAIN

#ifdef MAIN
void main()
{
	setlocale(LC_ALL, "");
#ifdef DYNAMIC_MEMORY_1
#ifdef THEORY
	//Динамические массивы
/*
	Динамическим называется массив размер которого может быть задан во время выполнения программы.
	Предварительно этот размер можно вычислить или вести с клавиатуры размер динамического массива можно задать целочисленным переменным значением
	Чтобы обявить динамический массив нужно объявить указатель и выделить память следующим образом:
*/
#endif // THEORY

	int n;   //размер массива
	cout << "Введите размер массива: "; cin >> n;
	int* arr = new int[n] {};

	//cout << int() << endl;//Выводим значение по умолчанию для типа данных int

	FillRand(arr, n);
	Print(arr, n);

#ifdef THEORY
	// Добавить значение в конец массива
/*int* buffer = new int[n + 1]{};
int value;
for (int i = 0; i < n; i++)
{
	buffer[i] = arr[i];
}
cout << "Введите добавляемое значение: "; cin >> value;
buffer[n] = value;
delete[] arr;
arr = buffer;
n++;*/
#endif // THEORY

#ifdef DZ
//ДЗ

//Добавляет значение в конец массива
//arr = push_back(arr, n);

//Добавляет значение в начало массива
//arr = push_front(arr, n);

//Добавляет значение в массив по указанному индексу
//arr = insert(arr, n);

//Удаляет последний элемент из массива
//arr = pop_back(arr, n);

//Удаляет нулевой элемент из массива
//arr = pop_front(arr, n);

//Удаляет значение из массива по указанному индексу
//arr = erase(arr, n);  

#endif // DZ

	Print(arr, n);

#ifdef THEORY
	//Обращаться к элементам массива можно 
//for (int i = 0; i < n; i++)
//{
//	//Используя арифметику указателей и оператор разыменования
//	*(arr + i) = rand() % 100;
//}
//for (int i = 0; i < n; i++)
//{
//	//или же через оператор индексирования[]
//	cout << arr[i] << "\t";
//}  
#endif // THEORY

	delete[] arr;
#endif // DYNAMIC_MEMORY_1

#ifdef DYNAMIC_MEMORY_2
	//int rows;		//Количество строк 
	//int cols;		//Количество элементов строки
	//cout << "Введите количество строк: "; cin >> rows;
	//cout << "Введите количество элементов строки: "; cin >> cols;
	//int** arr = new int* [rows] {};
	//for (int i = 0; i < rows; i++)
	//{
	//	arr[i] = new int[cols] {};
	//}
	//FillRand(arr, rows, cols);
	//Print(arr, rows, cols);
	////удаление строк
	//for (int i = 0; i < rows; i++)
	//{
	//	delete[] arr[i];
	//}
	////удаление массива указателей
	//delete[] arr;

	int rows;
	int cols;
	int index;
	cout << "Введите количество строк: "; cin >> rows;
	cout << "Введите количество элементов строки: "; cin >> cols;
	cout << "Введите индекс строки: "; cin >> index;
	char** arr = allocate<char>(rows, cols);
	FillRand(arr, rows, cols);
	Print(arr, rows, cols);
	cout << delimiter << endl;

	arr = push_row_back(arr, rows, cols);
	FillRand(arr[rows - 1], cols, 200, 400);

	//push_col_back(arr, rows, cols);
	//FillRandCol(arr, rows, cols, cols - 1, 200, 400);

	//arr = push_row_front(arr, rows, cols);
	//FillRand(arr[0], cols,200,400);

	//push_col_front(arr, rows, cols);
	//FillRandCol(arr, rows, cols, 0, 200, 400);

	//arr = insert_row(arr, rows, cols,index);
	//FillRand(arr[index-1], cols, 200, 400);

	//arr = insert_col(arr, rows, cols,index);
	//FillRandCol(arr, rows, cols, index - 1, 200, 400);

	//arr = pop_row_back(arr, rows, cols);
	//pop_col_back(arr, rows, cols);
	//arr = pop_row_front(arr, rows, cols);
	//pop_col_front(arr, rows, cols);
	//arr = erase_row(arr, rows, cols, index);
	//erase_col(arr, rows, cols, index);

	Print(arr, rows, cols);
	clear(arr, rows);
#endif // DYNAMIC_MEMORY_2


}

#endif // MAIN



#ifdef THEORY
/*
Чтобы объявить динамический массив нужно выделить память след образом int* arr = new int[n];
Оператор new выделяет непрерывную область памяти для n элементов типа int и возвращает адрес выделенной памяти этот адрес мы присваиваем указателю arr
Вотличии от статического массива который хранится в статической памяти(stack) динамический массив хранится в динамической памяти(heap)
Heap(куча) - куча свободной оперативной памяти в ОС когда оператор new выделяет память он фактически запрашивает её у Операционной Системе если непрерывный блок памяти опред кол памяти есть у ОС то она её выделяет в противном случае может возникнуть ошибка на этапе выполнения
*/

/*
	Обращение к элементам динамического массива
	К элементам динамического массива можно обращатся точно также как к элементам статического массива используя арифметику указ и оператор разыменования(*(arr + i) = rand() % 100;) или же через оператор индексирования[]
	Динамический массив также можно передавать в функцию как и статические массивы, при этом функция не сможет отличить статический массив от динамического
*/

/*
	После того как массив уже не нужен его нужно удалить это делает оператор delete[]
	Оператор delete удаляет массив освобождает занимаемую им память и возвращает её обратно ОС
	Если только выделять память и не возвращать её ОС то рано или поздно свободная оперативная память закончится что привидёт к аварийному завершению нашей программы с потерей данных по этому операторов delete должно быть ровно столько сколько операторов new
*/
#endif // THEORY

#ifdef THEORY
//Двумерные динамические массивы
/*
	Для того что бы обявить двумерный динамический массив нужно обявить указатель на указатель и выделить память для массива указателей.
	Каждый элемент массива указателей будет хранить адрес какойто одной строки двумерного массива.
	Только после этого можно создавать строки двумерного массива.
	Обращятся к элементам двумерного дин массива можно также как к элементам одномерного дин массива используя вложенный цикл и двойные квадратные скобки
	Для того что бы передать двумерный дин массив в функцию достаточно что бы функция принемала указатель на указатель
*/
#endif // THEORY


